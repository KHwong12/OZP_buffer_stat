import{a as X}from"./vec33.73d048e0.js";import{c as ae,u as ie,r as ue,e as ce}from"./types.1cdd5066.js";import{d1 as K,ay as de,jf as Q,h as W,U as fe,iq as le,bL as pe,s as k,a6 as me,i as Z,jg as ye,j4 as ee,f as he,jh as Te,g0 as be,fx as xe,gn as Se,fE as we,ji as Ie,e as Y,al as ge,hw as _e}from"./index.4188ada5.js";import{e as te,r as re}from"./mat4f64.84d5c445.js";import{D as G,L as j,C as l,E as L}from"./enums.de935fa5.js";import{x as Ee}from"./quat.92b5aa26.js";import{e as Ne}from"./quatf64.ddec7ef6.js";import{B as Oe,g as Ae,d as Re,i as V,c as H,u as ne,x as Ce,L as Be,O as Ue,E as Me,F as Le,w as ve,q as $e,A as Fe,V as Pe}from"./BufferView.4090ce60.js";import{l as De}from"./geometryDataUtils.9941546e.js";function Ge(o,e,t){if(o.count!==e.count)return void X.error("source and destination buffers need to have the same number of elements");const n=o.count,r=t[0],s=t[1],a=t[2],c=t[3],u=t[4],i=t[5],d=t[6],f=t[7],p=t[8],m=t[9],y=t[10],b=t[11],N=t[12],I=t[13],x=t[14],S=t[15],h=o.typedBuffer,g=o.typedBufferStride,T=e.typedBuffer,O=e.typedBufferStride;for(let _=0;_<n;_++){const E=_*g,R=_*O,C=T[R],B=T[R+1],U=T[R+2],M=T[R+3];h[E]=r*C+u*B+p*U+N*M,h[E+1]=s*C+i*B+m*U+I*M,h[E+2]=a*C+d*B+y*U+x*M,h[E+3]=c*C+f*B+b*U+S*M}}function je(o,e,t){if(o.count!==e.count)return void X.error("source and destination buffers need to have the same number of elements");const n=o.count,r=t[0],s=t[1],a=t[2],c=t[3],u=t[4],i=t[5],d=t[6],f=t[7],p=t[8],m=o.typedBuffer,y=o.typedBufferStride,b=e.typedBuffer,N=e.typedBufferStride;for(let I=0;I<n;I++){const x=I*y,S=I*N,h=b[S],g=b[S+1],T=b[S+2],O=b[S+3];m[x]=r*h+c*g+d*T,m[x+1]=s*h+u*g+f*T,m[x+2]=a*h+i*g+p*T,m[x+3]=O}}function Ve(o,e){const t=Math.min(o.count,e.count),n=o.typedBuffer,r=o.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride;for(let c=0;c<t;c++){const u=c*r,i=c*a,d=s[i],f=s[i+1],p=s[i+2],m=d*d+f*f+p*p;if(m>0){const y=1/Math.sqrt(m);n[u]=y*d,n[u+1]=y*f,n[u+2]=y*p}}}function ke(o,e,t){const n=Math.min(o.count,e.count),r=o.typedBuffer,s=o.typedBufferStride,a=e.typedBuffer,c=e.typedBufferStride;for(let u=0;u<n;u++){const i=u*s,d=u*c;r[i]=t*a[d],r[i+1]=t*a[d+1],r[i+2]=t*a[d+2],r[i+3]=t*a[d+3]}}function Ye(o,e,t){const n=Math.min(o.count,e.count),r=o.typedBuffer,s=o.typedBufferStride,a=e.typedBuffer,c=e.typedBufferStride;for(let u=0;u<n;u++){const i=u*s,d=u*c;r[i]=a[d]>>t,r[i+1]=a[d+1]>>t,r[i+2]=a[d+2]>>t,r[i+3]=a[d+3]>>t}}Object.freeze(Object.defineProperty({__proto__:null,transformMat4:Ge,transformMat3:je,normalize:Ve,scale:ke,shiftRight:Ye},Symbol.toStringTag,{value:"Module"}));function He(o,e,t){const n=o.typedBuffer,r=o.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d){for(let f=0;f<9;++f)n[u+f]=s[i+f];u+=r,i+=a}}Object.freeze(Object.defineProperty({__proto__:null,copy:He},Symbol.toStringTag,{value:"Module"}));function qe(o,e,t){const n=o.typedBuffer,r=o.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d){for(let f=0;f<16;++f)n[u+f]=s[i+f];u+=r,i+=a}}Object.freeze(Object.defineProperty({__proto__:null,copy:qe},Symbol.toStringTag,{value:"Module"}));function ze(o,e,t){const n=o.typedBuffer,r=o.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d)n[u]=s[i],u+=r,i+=a}function P(o,e){const t=o.count;e||(e=new o.TypedArrayConstructor(t));for(let n=0;n<t;n++)e[n]=o.get(n);return e}Object.freeze(Object.defineProperty({__proto__:null,copy:ze,makeDense:P},Symbol.toStringTag,{value:"Module"}));function oe(o,e,t){const n=o.typedBuffer,r=o.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d)n[u]=s[i],n[u+1]=s[i+1],u+=r,i+=a}function Je(o,e,t){const n=o.typedBuffer,r=o.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;if(ae(e.elementType)){const d=ie(e.elementType);if(ue(e.elementType))for(let f=0;f<c;++f)n[u]=Math.max(s[i]/d,-1),n[u+1]=Math.max(s[i+1]/d,-1),u+=r,i+=a;else for(let f=0;f<c;++f)n[u]=s[i]/d,n[u+1]=s[i+1]/d,u+=r,i+=a}else oe(o,e,t);return o}function Xe(o,e,t,n){var u,i;const r=o.typedBuffer,s=o.typedBufferStride,a=(u=n==null?void 0:n.count)!=null?u:o.count;let c=((i=n==null?void 0:n.dstIndex)!=null?i:0)*s;for(let d=0;d<a;++d)r[c]=e,r[c+1]=t,c+=s}Object.freeze(Object.defineProperty({__proto__:null,copy:oe,normalizeIntegerBuffer:Je,fill:Xe},Symbol.toStringTag,{value:"Module"}));function Ke(o,e,t){const n=o.typedBuffer,r=o.typedBufferStride,s=e.typedBuffer,a=e.typedBufferStride,c=t?t.count:e.count;let u=(t&&t.dstIndex?t.dstIndex:0)*r,i=(t&&t.srcIndex?t.srcIndex:0)*a;for(let d=0;d<c;++d)n[u]=s[i],n[u+1]=s[i+1],n[u+2]=s[i+2],n[u+3]=s[i+3],u+=r,i+=a}function Qe(o,e,t,n,r,s){var d,f;const a=o.typedBuffer,c=o.typedBufferStride,u=(d=s==null?void 0:s.count)!=null?d:o.count;let i=((f=s==null?void 0:s.dstIndex)!=null?f:0)*c;for(let p=0;p<u;++p)a[i]=e,a[i+1]=t,a[i+2]=n,a[i+3]=r,i+=c}Object.freeze(Object.defineProperty({__proto__:null,copy:Ke,fill:Qe},Symbol.toStringTag,{value:"Module"}));function Ut(o,e){return new o(new ArrayBuffer(e*o.ElementCount*ce(o.ElementType)))}class Mt{constructor(e){this.streamDataRequester=e}async loadJSON(e,t){return this._load("json",e,t)}async loadBinary(e,t){return K(e)?(de(t),Q(e)):this._load("binary",e,t)}async loadImage(e,t){return this._load("image",e,t)}async _load(e,t,n){if(W(this.streamDataRequester))return(await fe(t,{responseType:We[e]})).data;const r=await le(this.streamDataRequester.request(t,e,n));if(r.ok===!0)return r.value;throw pe(r.error),new k("",`Request for resource failed: ${r.error}`)}}const We={image:"image",binary:"array-buffer",json:"json"},Ze=me.getLogger("esri.views.3d.glTF");class et{error(e){throw new k("gltf-loader-error",e)}errorUnsupported(e){throw new k("gltf-loader-unsupported-feature",e)}errorUnsupportedIf(e,t){e&&this.errorUnsupported(t)}assert(e,t){e||this.error(t)}warn(e){Ze.warn(e)}warnUnsupported(e){this.warn("[Unsupported Feature] "+e)}warnUnsupportedIf(e,t){e&&this.warnUnsupported(t)}}function tt(o={}){return{color:[1,1,1],opacity:1,alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1,castShadows:!0,receiveShadows:!0,receiveAmbientOcclustion:!0,textureColor:null,textureNormal:null,textureOcclusion:null,textureEmissive:null,textureMetallicRoughness:null,emissiveFactor:[0,0,0],metallicFactor:1,roughnessFactor:1,colorMixMode:"multiply",...o}}function rt(o,e={}){return{data:o,parameters:{wrap:{s:G.REPEAT,t:G.REPEAT,...e.wrap},noUnpackFlip:!0,mipmap:!1,...e}}}class q{constructor(e){this.data=e,this.offset4=0,this.dataUint32=new Uint32Array(this.data,0,Math.floor(this.data.byteLength/4))}readUint32(){const e=this.offset4;return this.offset4+=1,this.dataUint32[e]}readUint8Array(e){const t=4*this.offset4;return this.offset4+=e/4,new Uint8Array(this.data,t,e)}remainingBytes(){return this.data.byteLength-4*this.offset4}}var A,z;(function(o){o.SCALAR="SCALAR",o.VEC2="VEC2",o.VEC3="VEC3",o.VEC4="VEC4",o.MAT2="MAT2",o.MAT3="MAT3",o.MAT4="MAT4"})(A||(A={})),function(o){o[o.ARRAY_BUFFER=34962]="ARRAY_BUFFER",o[o.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"}(z||(z={}));const se={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1},nt={pbrMetallicRoughness:se,emissiveFactor:[0,0,0],alphaMode:"OPAQUE",alphaCutoff:.5,doubleSided:!1},ot={ESRI_externalColorMixMode:"tint"},J=(o={})=>{const e={...se,...o.pbrMetallicRoughness},t=st({...ot,...o.extras});return{...nt,...o,pbrMetallicRoughness:e,extras:t}};function st(o){switch(o.ESRI_externalColorMixMode){case"multiply":case"tint":case"ignore":case"replace":break;default:Z(o.ESRI_externalColorMixMode),o.ESRI_externalColorMixMode="tint"}return o}const at={magFilter:j.LINEAR,minFilter:j.LINEAR_MIPMAP_LINEAR,wrapS:G.REPEAT,wrapT:G.REPEAT},it=o=>({...at,...o});function ut(o){let e,t;return o.replace(/^(.*\/)?([^/]*)$/,(n,r,s)=>(e=r||"",t=s||"","")),{dirPart:e,filePart:t}}const v={MAGIC:1179937895,CHUNK_TYPE_JSON:1313821514,CHUNK_TYPE_BIN:5130562,MIN_HEADER_LENGTH:20};class w{constructor(e,t,n,r,s){this.context=e,this.errorContext=t,this.uri=n,this.json=r,this.glbBuffer=s,this.bufferLoaders=new Map,this.textureLoaders=new Map,this.textureCache=new Map,this.materialCache=new Map,this.nodeParentMap=new Map,this.nodeTransformCache=new Map,this.baseUri=ut(this.uri).dirPart,this._checkVersionSupported(),this._checkRequiredExtensionsSupported(),t.errorUnsupportedIf(r.scenes==null,"Scenes must be defined."),t.errorUnsupportedIf(r.meshes==null,"Meshes must be defined"),t.errorUnsupportedIf(r.nodes==null,"Nodes must be defined."),this._computeNodeParents()}static async load(e,t,n,r){if(K(n)){const c=he(n);if(c.mediaType!=="model/gltf-binary")try{const i=JSON.parse(c.isBase64?atob(c.data):c.data);return new w(e,t,n,i)}catch{}const u=Q(n);if(w._isGLBData(u))return this._fromGLBData(e,t,n,u)}if(n.endsWith(".gltf")){const c=await e.loadJSON(n,r);return new w(e,t,n,c)}const s=await e.loadBinary(n,r);if(w._isGLBData(s))return this._fromGLBData(e,t,n,s);const a=await e.loadJSON(n,r);return new w(e,t,n,a)}static _isGLBData(e){const t=new q(e);return t.remainingBytes()>=4&&t.readUint32()===v.MAGIC}static async _fromGLBData(e,t,n,r){const s=await w._parseGLBData(t,r);return new w(e,t,n,s.json,s.binaryData)}static async _parseGLBData(e,t){const n=new q(t);e.assert(n.remainingBytes()>=12,"GLB binary data is insufficiently large.");const r=n.readUint32(),s=n.readUint32(),a=n.readUint32();e.assert(r===v.MAGIC,"Magic first 4 bytes do not fit to expected GLB value."),e.assert(t.byteLength>=a,"GLB binary data is smaller than header specifies."),e.errorUnsupportedIf(s!==2,"An unsupported GLB container version was detected. Only version 2 is supported.");let c,u,i=0;for(;n.remainingBytes()>=8;){const d=n.readUint32(),f=n.readUint32();i===0?(e.assert(f===v.CHUNK_TYPE_JSON,"First GLB chunk must be JSON."),e.assert(d>=0,"No JSON data found."),c=await mt(n.readUint8Array(d))):i===1?(e.errorUnsupportedIf(f!==v.CHUNK_TYPE_BIN,"Second GLB chunk expected to be BIN."),u=n.readUint8Array(d)):e.warnUnsupported("More than 2 GLB chunks detected. Skipping."),i+=1}return c||e.error("No GLB JSON chunk detected."),{json:c,binaryData:u}}async getBuffer(e,t){const n=this.json.buffers[e],r=this.errorContext;if(n.uri==null)return r.assert(this.glbBuffer!=null,"GLB buffer not present"),this.glbBuffer;const s=await this._getBufferLoader(e,t);return r.assert(s.byteLength===n.byteLength,"Buffer byte lengths should match."),s}async _getBufferLoader(e,t){const n=this.bufferLoaders.get(e);if(n)return n;const r=this.json.buffers[e],s=this.context.loadBinary(this._resolveUri(r.uri),t).then(a=>new Uint8Array(a));return this.bufferLoaders.set(e,s),s}async getAccessor(e,t){const n=this.errorContext;n.errorUnsupportedIf(!this.json.accessors,"Accessors missing.");const r=this.json.accessors[e];n.errorUnsupportedIf((r==null?void 0:r.bufferView)==null,"Some accessor does not specify a bufferView."),n.errorUnsupportedIf(r.type in[A.MAT2,A.MAT3,A.MAT4],`AttributeType ${r.type} is not supported`);const s=this.json.bufferViews[r.bufferView],a=await this.getBuffer(s.buffer,t),c=ft[r.type],u=lt[r.componentType],i=c*u,d=s.byteStride||i;return{raw:a.buffer,byteStride:d,byteOffset:a.byteOffset+(s.byteOffset||0)+(r.byteOffset||0),entryCount:r.count,isDenselyPacked:d===i,componentCount:c,componentByteSize:u,componentType:r.componentType,min:r.min,max:r.max,normalized:!!r.normalized}}async getIndexData(e,t){if(e.indices==null)return null;const n=await this.getAccessor(e.indices,t);if(n.isDenselyPacked)switch(n.componentType){case l.UNSIGNED_BYTE:return new Uint8Array(n.raw,n.byteOffset,n.entryCount);case l.UNSIGNED_SHORT:return new Uint16Array(n.raw,n.byteOffset,n.entryCount);case l.UNSIGNED_INT:return new Uint32Array(n.raw,n.byteOffset,n.entryCount)}else switch(n.componentType){case l.UNSIGNED_BYTE:return P(this._wrapAccessor(Re,n));case l.UNSIGNED_SHORT:return P(this._wrapAccessor(Ae,n));case l.UNSIGNED_INT:return P(this._wrapAccessor(Oe,n))}}async getPositionData(e,t){const n=this.errorContext;n.errorUnsupportedIf(e.attributes.POSITION==null,"No POSITION vertex data found.");const r=await this.getAccessor(e.attributes.POSITION,t);return n.errorUnsupportedIf(r.componentType!==l.FLOAT,"Expected type FLOAT for POSITION vertex attribute, but found "+F[r.componentType]),n.errorUnsupportedIf(r.componentCount!==3,"POSITION vertex attribute must have 3 components, but found "+r.componentCount.toFixed()),this._wrapAccessor(V,r)}async getNormalData(e,t){const n=this.errorContext;n.assert(e.attributes.NORMAL!=null,"No NORMAL vertex data found.");const r=await this.getAccessor(e.attributes.NORMAL,t);return n.errorUnsupportedIf(r.componentType!==l.FLOAT,"Expected type FLOAT for NORMAL vertex attribute, but found "+F[r.componentType]),n.errorUnsupportedIf(r.componentCount!==3,"NORMAL vertex attribute must have 3 components, but found "+r.componentCount.toFixed()),this._wrapAccessor(V,r)}async getTangentData(e,t){const n=this.errorContext;n.assert(e.attributes.TANGENT!=null,"No TANGENT vertex data found.");const r=await this.getAccessor(e.attributes.TANGENT,t);return n.errorUnsupportedIf(r.componentType!==l.FLOAT,"Expected type FLOAT for TANGENT vertex attribute, but found "+F[r.componentType]),n.errorUnsupportedIf(r.componentCount!==4,"TANGENT vertex attribute must have 4 components, but found "+r.componentCount.toFixed()),new H(r.raw,r.byteOffset,r.byteStride,r.byteOffset+r.byteStride*r.entryCount)}async getTextureCoordinates(e,t){const n=this.errorContext;n.assert(e.attributes.TEXCOORD_0!=null,"No TEXCOORD_0 vertex data found.");const r=await this.getAccessor(e.attributes.TEXCOORD_0,t);return n.errorUnsupportedIf(r.componentCount!==2,"TEXCOORD_0 vertex attribute must have 2 components, but found "+r.componentCount.toFixed()),r.componentType===l.FLOAT?this._wrapAccessor(ne,r):(n.errorUnsupportedIf(!r.normalized,"Integer component types are only supported for a normalized accessor for TEXCOORD_0."),pt(r))}async getVertexColors(e,t){const n=this.errorContext;n.assert(e.attributes.COLOR_0!=null,"No COLOR_0 vertex data found.");const r=await this.getAccessor(e.attributes.COLOR_0,t);if(n.errorUnsupportedIf(r.componentCount!==4&&r.componentCount!==3,"COLOR_0 attribute must have 3 or 4 components, but found "+r.componentCount.toFixed()),r.componentCount===4){if(r.componentType===l.FLOAT)return this._wrapAccessor(H,r);if(r.componentType===l.UNSIGNED_BYTE)return this._wrapAccessor(Ce,r);if(r.componentType===l.UNSIGNED_SHORT)return this._wrapAccessor(Be,r)}else if(r.componentCount===3){if(r.componentType===l.FLOAT)return this._wrapAccessor(V,r);if(r.componentType===l.UNSIGNED_BYTE)return this._wrapAccessor(Ue,r);if(r.componentType===l.UNSIGNED_SHORT)return this._wrapAccessor(Me,r)}n.errorUnsupported("Unsupported component type for COLOR_0 attribute: "+F[r.componentType])}hasPositions(e){return e.attributes.POSITION!==void 0}hasNormals(e){return e.attributes.NORMAL!==void 0}hasVertexColors(e){return e.attributes.COLOR_0!==void 0}hasTextureCoordinates(e){return e.attributes.TEXCOORD_0!==void 0}hasTangents(e){return e.attributes.TANGENT!==void 0}async getMaterial(e,t,n){let r=this.materialCache.get(e.material);if(!r){const s=e.material!=null?J(this.json.materials[e.material]):J(),a=s.pbrMetallicRoughness,c=this.hasVertexColors(e),u=this.getTexture(a.baseColorTexture,t),i=this.getTexture(s.normalTexture,t),d=n?this.getTexture(s.occlusionTexture,t):null,f=n?this.getTexture(s.emissiveTexture,t):null,p=n?this.getTexture(a.metallicRoughnessTexture,t):null,m=e.material!=null?e.material:-1;r={alphaMode:s.alphaMode,alphaCutoff:s.alphaCutoff,color:a.baseColorFactor,doubleSided:!!s.doubleSided,colorTexture:await u,normalTexture:await i,name:s.name,id:m,occlusionTexture:await d,emissiveTexture:await f,emissiveFactor:s.emissiveFactor,metallicFactor:a.metallicFactor,roughnessFactor:a.roughnessFactor,metallicRoughnessTexture:await p,hasVertexColors:c,ESRI_externalColorMixMode:s.extras.ESRI_externalColorMixMode}}return r}async getTexture(e,t){if(!e)return null;this.errorContext.errorUnsupportedIf((e.texCoord||0)!==0,"Only TEXCOORD with index 0 is supported.");const n=e.index,r=this.errorContext,s=this.json.textures[n],a=it(s.sampler!=null?this.json.samplers[s.sampler]:{});r.errorUnsupportedIf(s.source==null,"Source is expected to be defined for a texture.");const c=this.json.images[s.source],u=await this._loadTextureImageData(n,s,t);return Te(this.textureCache,n,()=>{const i=f=>f===33071||f===33648||f===10497,d=f=>(r.error(`Unexpected TextureSampler WrapMode: ${f}. Using default REPEAT(10497).`),10497);return{data:u,wrapS:i(a.wrapS)?a.wrapS:d(a.wrapS),wrapT:i(a.wrapT)?a.wrapT:d(a.wrapT),minFilter:a.minFilter,name:c.name,id:n}})}getNodeTransform(e){if(e===void 0)return dt;let t=this.nodeTransformCache.get(e);if(!t){const n=this.getNodeTransform(this._getNodeParent(e)),r=this.json.nodes[e];r.matrix?t=be(te(),n,r.matrix):r.translation||r.rotation||r.scale?(t=re(n),r.translation&&xe(t,t,r.translation),r.rotation&&($[3]=Ee($,r.rotation),Se(t,t,$[3],$)),r.scale&&we(t,t,r.scale)):t=n,this.nodeTransformCache.set(e,t)}return t}_wrapAccessor(e,t){return new e(t.raw,t.byteOffset,t.byteStride,t.byteOffset+t.byteStride*(t.entryCount-1)+t.componentByteSize*t.componentCount)}_resolveUri(e){return Ie(e,this.baseUri)}_getNodeParent(e){return this.nodeParentMap.get(e)}_checkVersionSupported(){const e=ee.parse(this.json.asset.version,"glTF");ct.validate(e)}_checkRequiredExtensionsSupported(){const e=this.json,t=this.errorContext;e.extensionsRequired&&e.extensionsRequired.length!==0&&t.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: "+e.extensionsRequired.join(", "))}_computeNodeParents(){this.json.nodes.forEach((e,t)=>{e.children&&e.children.forEach(n=>{this.nodeParentMap.set(n,t)})})}async _loadTextureImageData(e,t,n){const r=this.textureLoaders.get(e);if(r)return r;const s=this._createTextureLoader(t,n);return this.textureLoaders.set(e,s),s}async _createTextureLoader(e,t){const n=this.json.images[e.source];if(n.uri)return this.context.loadImage(this._resolveUri(n.uri),t);const r=this.errorContext;r.errorUnsupportedIf(n.bufferView==null,"Image bufferView must be defined."),r.errorUnsupportedIf(n.mimeType==null,"Image mimeType must be defined.");const s=this.json.bufferViews[n.bufferView],a=await this.getBuffer(s.buffer,t);return r.errorUnsupportedIf(s.byteStride!=null,"byteStride not supported for image buffer"),yt(new Uint8Array(a.buffer,a.byteOffset+(s.byteOffset||0),s.byteLength),n.mimeType)}}const ct=new ee(2,0,"glTF"),dt=ye(te(),Math.PI/2),$=Ne(),ft={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},lt={[l.BYTE]:1,[l.UNSIGNED_BYTE]:1,[l.SHORT]:2,[l.UNSIGNED_SHORT]:2,[l.FLOAT]:4,[l.UNSIGNED_INT]:4};function pt(o){switch(o.componentType){case l.BYTE:return new Pe(o.raw,o.byteOffset,o.byteStride,o.byteOffset+o.byteStride*o.entryCount);case l.UNSIGNED_BYTE:return new Fe(o.raw,o.byteOffset,o.byteStride,o.byteOffset+o.byteStride*o.entryCount);case l.SHORT:return new $e(o.raw,o.byteOffset,o.byteStride,o.byteOffset+o.byteStride*o.entryCount);case l.UNSIGNED_SHORT:return new ve(o.raw,o.byteOffset,o.byteStride,o.byteOffset+o.byteStride*o.entryCount);case l.UNSIGNED_INT:return new Le(o.raw,o.byteOffset,o.byteStride,o.byteOffset+o.byteStride*o.entryCount);case l.FLOAT:return new ne(o.raw,o.byteOffset,o.byteStride,o.byteOffset+o.byteStride*o.entryCount);default:return void Z(o.componentType)}}async function mt(o){return new Promise((e,t)=>{const n=new Blob([o]),r=new FileReader;r.onload=()=>{const s=r.result;e(JSON.parse(s))},r.onerror=s=>{t(s)},r.readAsText(n)})}async function yt(o,e){return new Promise((t,n)=>{const r=new Blob([o],{type:e}),s=URL.createObjectURL(r),a=new Image;a.addEventListener("load",()=>{URL.revokeObjectURL(s),"decode"in a?a.decode().then(()=>t(a),()=>t(a)):t(a)}),a.addEventListener("error",c=>{URL.revokeObjectURL(s),n(c)}),a.src=s})}const F={5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5125:"UNSIGNED_INT",5126:"FLOAT"};let ht=0;async function Lt(o,e,t={},n=!0){const r=await w.load(o,D,e,t),s="gltf_"+ht++,a={lods:[],materials:new Map,textures:new Map,meta:Tt(r)},c=!(!r.json.asset.extras||r.json.asset.extras.ESRI_type!=="symbolResource"),u=new Map;await bt(r,async(i,d,f,p)=>{var E;const m=(E=u.get(f))!=null?E:0;u.set(f,m+1);const y=i.mode!==void 0?i.mode:L.TRIANGLES,b=y===L.TRIANGLES||y===L.TRIANGLE_STRIP||y===L.TRIANGLE_FAN?y:null;if(W(b))return void D.warnUnsupported("Unsupported primitive mode ("+It[y]+"). Skipping primitive.");if(!r.hasPositions(i))return void D.warn("Skipping primitive without POSITION vertex attribute.");const N=r.getPositionData(i,t),I=r.getMaterial(i,t,n),x=r.hasNormals(i)?r.getNormalData(i,t):null,S=r.hasTangents(i)?r.getTangentData(i,t):null,h=r.hasTextureCoordinates(i)?r.getTextureCoordinates(i,t):null,g=r.hasVertexColors(i)?r.getVertexColors(i,t):null,T=r.getIndexData(i,t),O={transform:re(d),attributes:{position:await N,normal:x?await x:null,texCoord0:h?await h:null,color:g?await g:null,tangent:S?await S:null},indices:await T,primitiveType:b,material:St(a,await I,s)};let _=null;Y(a.meta)&&Y(a.meta.ESRI_lod)&&a.meta.ESRI_lod.metric==="screenSpaceRadius"&&(_=a.meta.ESRI_lod.thresholds[f]),a.lods[f]=a.lods[f]||{parts:[],name:p,lodThreshold:_},a.lods[f].parts[m]=O});for(const i of a.lods)i.parts=i.parts.filter(d=>!!d);return{model:a,meta:{isEsriSymbolResource:c,uri:r.uri},customMeta:{}}}function Tt(o){const e=o.json;let t=null;return e.nodes.forEach(n=>{const r=n.extras;Y(r)&&(r.ESRI_proxyEllipsoid||r.ESRI_lod)&&(t=r)}),t}async function bt(o,e){const t=o.json,n=t.scenes[t.scene||0].nodes,r=n.length>1,s=[];for(const c of n){const u=t.nodes[c];s.push(a(c,0)),xt(u)&&!r&&u.extensions.MSFT_lod.ids.forEach((i,d)=>a(i,d+1))}async function a(c,u){const i=t.nodes[c],d=o.getNodeTransform(c);if(D.warnUnsupportedIf(i.weights!=null,"Morph targets are not supported."),i.mesh!=null){const f=t.meshes[i.mesh];for(const p of f.primitives)s.push(e(p,d,u,f.name))}for(const f of i.children||[])s.push(a(f,u))}await Promise.all(s)}function xt(o){return o.extensions&&o.extensions.MSFT_lod&&Array.isArray(o.extensions.MSFT_lod.ids)}function St(o,e,t){const n=s=>{const a=`${t}_tex_${s&&s.id}${s&&s.name?"_"+s.name:""}`;if(s&&!o.textures.has(a)){const c=rt(s.data,{wrap:{s:s.wrapS,t:s.wrapT},mipmap:wt.includes(s.minFilter),noUnpackFlip:!0});o.textures.set(a,c)}return a},r=`${t}_mat_${e.id}_${e.name}`;if(!o.materials.has(r)){const s=tt({color:[e.color[0],e.color[1],e.color[2]],opacity:e.color[3],alphaMode:e.alphaMode,alphaCutoff:e.alphaCutoff,doubleSided:e.doubleSided,colorMixMode:e.ESRI_externalColorMixMode,textureColor:e.colorTexture?n(e.colorTexture):void 0,textureNormal:e.normalTexture?n(e.normalTexture):void 0,textureOcclusion:e.occlusionTexture?n(e.occlusionTexture):void 0,textureEmissive:e.emissiveTexture?n(e.emissiveTexture):void 0,textureMetallicRoughness:e.metallicRoughnessTexture?n(e.metallicRoughnessTexture):void 0,emissiveFactor:[e.emissiveFactor[0],e.emissiveFactor[1],e.emissiveFactor[2]],metallicFactor:e.metallicFactor,roughnessFactor:e.roughnessFactor});o.materials.set(r,s)}return r}const D=new et,wt=[j.LINEAR_MIPMAP_LINEAR,j.LINEAR_MIPMAP_NEAREST],It=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"];function vt(o,e=De){return typeof o=="number"?e(o):ge(o)||_e(o)?new Uint32Array(o):o}function $t(o){const e=typeof o=="number"?o:o.length;if(e<3)return new Uint16Array(0);const t=e-2,n=t<=65536?new Uint16Array(3*t):new Uint32Array(3*t);if(typeof o=="number"){let r=0;for(let s=0;s<t;s+=1)s%2==0?(n[r++]=s,n[r++]=s+1,n[r++]=s+2):(n[r++]=s+1,n[r++]=s,n[r++]=s+2)}else{let r=0;for(let s=0;s<t;s+=1)if(s%2==0){const a=o[s],c=o[s+1],u=o[s+2];n[r++]=a,n[r++]=c,n[r++]=u}else{const a=o[s+1],c=o[s],u=o[s+2];n[r++]=a,n[r++]=c,n[r++]=u}}return n}function Ft(o){const e=typeof o=="number"?o:o.length;if(e<3)return new Uint16Array(0);const t=e-2,n=t<=65536?new Uint16Array(3*t):new Uint32Array(3*t);if(typeof o=="number"){let r=0;for(let s=0;s<t;++s)n[r++]=0,n[r++]=s+1,n[r++]=s+2;return n}{const r=o[0];let s=o[1],a=0;for(let c=0;c<t;++c){const u=o[c+2];n[a++]=r,n[a++]=s,n[a++]=u,s=u}return n}}const Pt=2.1;export{je as a,Je as b,Lt as c,ke as d,Ke as e,$t as f,vt as g,Ve as h,Ft as i,Xe as j,Ye as k,Mt as n,Pt as o,Ut as r,Qe as t};
